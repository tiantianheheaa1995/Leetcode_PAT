### 定义
动态规划是一种思想，没有固定的写法，非常灵活。多训练、多思考、多总结是学习动态规划的重点。

动态规划是用求解最优化问题。<br>
动态规划通过将求解过的每个子问题的解记录下来，如果遇到重叠子问题，就直接用记录的结果，不用重复计算了。称为记忆化搜索。<br>

动态规划可以用递归或递推来实现，递归中为了避免重复计算，采用的操作称为记忆化搜索。

**递归实现**：
```cpp
int F(int n){
    if(n==0 || n==1) return 1;  // 递归边界
    return F(n+1)+F(n+2);  // 递归式
}
```

**递归+记忆化搜索实现**：<br>
递归是自顶向下计算的，中间会有大量的重复计算。为了避免重复计算，可以开一个数组，存储已经计算过的结果，当再遇到重复子问题，直接用记录的结果。
```cpp
int F(int n){
    if(n == 0 || n == 1) return 1;  // 递归边界
    if(dp[n] != -1){  // 直接用记录的结果
        return dp[n];
    }else{  // 递归计算，并保持到数组
        dp[n] = F(n-1)+F(n-2);
        return dp[n];
    }
}
```
**递推实现**：<br>
数塔问题：第n层有n个数字，求一条路径将路径上的所有的数字相加后和最大。<br>
因为每个数字下面的道路有2个选择，如果遍历所有的路径，时间复杂度是O(2^n)。

设置一个状态，d[i][j]表示第i个行第j个数字到最底层的路的和的最大值。<br>
状态转移方程/递推式，dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + f[i][j]，就是下面两条路的最大值+当前的节点值。
递推边界，最下面一层的dp值就是元素本身，即dp[n][j]=f[n][j]，n是最下面一层。
```cpp
// 递推边界
for(int j = 1; j <= n; j++){
    dp[n][j] = f[n][j];
}
// 递推式，递推是从下向上的
for(int i = n-1; i >= 1; i--){
    for(int j = 1; j <= i; j++){
        dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + f[i][j];
    }
}
```
分析：<br>
（1）递推和递归都是两个条件，边界+状态转移。边界都是最底层。递推的状态转移是自底向上，递归的状态转移是自上向下。<br>
（2）递归中有重复计算，所以动态规划采取的策略是递归+记忆化搜索。递推中没有重复计算。<br>想一下水从上往下流，会有很多重复流动的地方。但是从下往上，所有的地方都是只流经一次。

**最优子结构**：<br>
如果一个问题的最优解可以通过其子问题的最优解求得，称这个问题拥有最优子结构。

一个问题必须拥有**重叠子结构**和**最优子结构**，才可以用动态规划去解决。

分治法和动态规划的区别：<br>
分治法解决的问题是不拥有重叠子问题，例如归并排序和快速排序分别处理左序列和右序列。<br>
动态规划解决的问题是拥有重叠子问题。<br>
分支法解决的不一定是最优化问题，动态规划解决的是最优化问题，且拥有最优子结构。

贪心和动态规划的区别：<br>
贪心和动态规划都是解决最优化问题，且都需要拥有最优子结构。<br>
贪心是每一步通过一种策略选择一个子问题求解，是单链流水的方式，不会求解所以的子问题。<br>
动态规划是等待所以的子问题都求解完毕后，在选择使用哪一个。



### 几个典型的问题
### 1、最大连续子序列和
**问题**：<br>
给定一个序列，求一个连续子序列，使得该连续子序列的和最大。

**暴力求解**：<br>
枚举左右端点需要O(n^2)的时间复杂度，计算连续子序列的和需要O(n)的时间复杂度，总体是O(n^3)的时间复杂度。

**动态规划求解**：<br>
（1）确定状态。dp[i]表示以元素A[i]结尾的连续子序列的最大和。<br>
（2）确定状态转移方程。dp[i] = max{A[i], dp[i-1]+A[i]}。<br>
（3）确定递推边界。dp[0] = A[0]。<br>
最后输出dp[0]，dp[1]，...，dp[n-1]中的最大值就是最大连续子序列的和。

```cpp
// 递推边界
dp[0] = A[0];
// 递推式
for(int i = 1; i < n; i++){
    dp[i] = max(A[i], dp[i-1]+A[i]);
}
```

状态的无后效性：<br>
每次计算状态dp[i]，只会涉及dp[i-1]，或几个历史状态，而不会使用到的全部的历史状态/历史信息。<br>

动态规划需要设计一个无后效性的状态和对应的状态转移方程。

### 2、最长不下降子序列（LIS）<br>
**问题**：<br>
一个序列中，找一个最长的子序列（可以不连续），使得这个子序列是非递减的。

**暴力求解**：<br>
枚举每种情况，每个元素有取和不取两种选择。如果元素有n个，时间复杂度是O(2^n)。

**动态规划**：<br>
（1）状态：dp[i]表示以A[i]结尾的最长不下降子序列长度。<br>
（2）状态转移方程：如果A[i]跟在A[j]结尾的LIS后，可以使得以A[i]结尾的LIS长度更长，就把A[i]跟在A[j]结尾的LIS后面。<br>
（3）边界：

```cpp
for(int i = 1; i <= n; i++){
    dp[i] = 1;  // 边界，初始每个元素自成一个子序列
    for(int j = 1; j < i; j++){
        if(A[i] >= A[j] && (dp[j] + 1 > dp[i])){
            dp[i] = dp[j] + 1;  // 状态转移方程
        }
    }
}
```

### 3、最长公共子序列（LCS）
**问题**：<br>
给定两个序列（数字或字符串），求一个字符串，是A和B的最长的公共子序列（可以不连续）。

**暴力求解**：<br>
假设A的长度是n，B的长度是m，对每个字符有选择和不选择两种取法，所以O(2^(m+n))，比较两个子序列是否相同需要O(max(m,n))。

**动态规划**：<br>
（1）状态：dp[i][j]是A的第i号位，B的第j号位，之前的LCS长度。<br>
（2）状态转移方程：<br>
（3）边界<br>



### 4、最长回文子串
**问题**：<br>
给一个字符串S，求S的最长回文子串的长度。

**暴力求解**：<br>
枚举子串的两个端点，需要O(n^2)的时间复杂度，判断这个区间是否为回文，需要O(n)，一共需要O(n^3)。

**动态规划求解**：<br>
（1）状态：dp[i][j]表示区间i和j内是回文子串。<br>
（2）状态转移方程：<br>
（3）边界：<br>


### 5、背包问题
一类经典的动态规划问题，背包问题十分灵活，这里只介绍两种最基本的背包问题：01背包和完全背包。

多阶段动态规划问题：<br>
一个动态规划问题的求解，可以分解为若干个有序的状态，且每个状态只和上一个状态有关。称为多阶段动态规划问题。<br>
01背包就是一个多阶段动态规划问题。

### 01背包问题：
**问题**：<br>
n件物品，每个物品的重量w[i]，价值c[i]，现在一个容量V的背包，选择物品放入背包，使得背包中的物品总价值是最大的。

**暴力求解**：<br>
每个物品可以放入，或者不放入，从而n件商品有O(2^n)时间复杂度。

**动态规划**：<br>
（1）状态：dp[i][v]表示前i件商品，装入容量是v的背包获得的最大价值。<br>
（2）状态转移方程：由于每件商品只有放或不放两种选择，所以dp[i][v] = max{dp[i-1][v], dp[i-1][v-w[i]]+c[i]}。<br>
（3）边界：dp[0][v]=0。<br>

```cpp
// 递推边界
for(int v = 0; v <= V; v++){
    dp[v] = 0;
}
for(int i = 0; i <= n; i++){
    for(int v = V; v >= w[i]; v--){
        dp[v] = max(dp[v], dp[v-w[i]]+c[i]);  // 递推式
    }
}
```


### 完全背包问题：
问题：<br>
上面的题干，每种商品有无穷件。

动态规划：<br>
（1）状态：<br>
（2）状态转移方程：<br>
（2）边界：<br>

和01背包的区别：<br>


### 题目1：PAT-A-1007-最大连续子序列和



### 题目2：PAT-A-1040-最长回文子串



### 题目3：PAT-A-1045-LIS/LCS


### 题目4：PAT-A-1068-01背包问题
